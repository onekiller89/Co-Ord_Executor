"""YouTube playlist watcher — polls a playlist for new videos to extract.

Uses YouTube Data API v3 to list playlist items and tracks which videos
have already been processed via a local state file + INDEX.md.

Playlist management (remove / add items) uses OAuth2 credentials
generated by ``python youtube_auth.py``.
"""

import json
import logging
from pathlib import Path

import requests
from google.auth.transport.requests import Request as GoogleAuthRequest
from google.oauth2.credentials import Credentials

import config

log = logging.getLogger("megamind.youtube")

# Local state file to track processed video IDs
STATE_FILE = config.PROJECT_ROOT / ".youtube_processed.json"


# ---------------------------------------------------------------------------
# OAuth2 helpers
# ---------------------------------------------------------------------------

def _load_oauth_credentials() -> Credentials | None:
    """Load and refresh OAuth2 credentials from the token file.

    Returns ``None`` if the token file doesn't exist (OAuth not set up yet).
    """
    token_path: Path = config.YOUTUBE_TOKEN_FILE
    if not token_path.exists():
        return None

    creds = Credentials.from_authorized_user_file(
        str(token_path),
        scopes=["https://www.googleapis.com/auth/youtube"],
    )

    # Auto-refresh if expired
    if creds.expired and creds.refresh_token:
        try:
            creds.refresh(GoogleAuthRequest())
            token_path.write_text(creds.to_json())
            log.debug("YouTube OAuth token refreshed")
        except Exception as exc:
            log.error(f"Failed to refresh YouTube OAuth token: {exc}")
            return None

    return creds


def _oauth_headers() -> dict[str, str] | None:
    """Return Authorization headers for YouTube API calls, or None."""
    creds = _load_oauth_credentials()
    if creds is None:
        return None
    return {"Authorization": f"Bearer {creds.token}"}


def oauth_available() -> bool:
    """Return True if a valid OAuth token is configured."""
    return _load_oauth_credentials() is not None


# ---------------------------------------------------------------------------
# State management
# ---------------------------------------------------------------------------

def _load_processed() -> set[str]:
    """Load the set of already-processed video IDs."""
    if STATE_FILE.exists():
        try:
            data = json.loads(STATE_FILE.read_text())
            return set(data.get("processed", []))
        except (json.JSONDecodeError, KeyError):
            return set()
    return set()


def _save_processed(video_ids: set[str]):
    """Save the set of processed video IDs."""
    STATE_FILE.write_text(json.dumps({"processed": sorted(video_ids)}, indent=2))


def mark_video_processed(video_id: str):
    """Mark a video as processed."""
    processed = _load_processed()
    processed.add(video_id)
    _save_processed(processed)


# ---------------------------------------------------------------------------
# Read playlist
# ---------------------------------------------------------------------------

def get_playlist_videos() -> list[dict]:
    """Fetch all videos from the YouTube extract playlist.

    Returns list of dicts with video_id, title, playlist_item_id.
    """
    if not config.YOUTUBE_API_KEY or not config.YOUTUBE_EXTRACT_PLAYLIST_ID:
        return []

    videos = []
    page_token = None

    while True:
        params = {
            "part": "snippet",
            "playlistId": config.YOUTUBE_EXTRACT_PLAYLIST_ID,
            "maxResults": 50,
            "key": config.YOUTUBE_API_KEY,
        }
        if page_token:
            params["pageToken"] = page_token

        resp = requests.get(
            "https://www.googleapis.com/youtube/v3/playlistItems",
            params=params,
        )

        if resp.status_code != 200:
            log.error(f"YouTube API error: {resp.status_code} {resp.text}")
            break

        data = resp.json()

        for item in data.get("items", []):
            snippet = item["snippet"]
            video_id = snippet.get("resourceId", {}).get("videoId")
            if video_id:
                videos.append({
                    "video_id": video_id,
                    "title": snippet.get("title", "Unknown"),
                    "playlist_item_id": item["id"],
                    "published_at": snippet.get("publishedAt", ""),
                })

        page_token = data.get("nextPageToken")
        if not page_token:
            break

    return videos


def get_new_playlist_videos() -> list[dict]:
    """Return only videos that haven't been processed yet."""
    all_videos = get_playlist_videos()
    processed = _load_processed()

    # Also check INDEX.md for YouTube URLs already extracted
    index_video_ids = _get_indexed_youtube_ids()
    already_done = processed | index_video_ids

    new_videos = [v for v in all_videos if v["video_id"] not in already_done]

    if new_videos:
        log.info(f"Found {len(new_videos)} new video(s) in playlist")
    return new_videos


def _get_indexed_youtube_ids() -> set[str]:
    """Scan INDEX.md for already-extracted YouTube video IDs."""
    ids = set()
    if config.INDEX_FILE.exists():
        content = config.INDEX_FILE.read_text()
        import re
        # Match YouTube video IDs in index entries
        for match in re.finditer(r"youtube\.com/watch\?v=([a-zA-Z0-9_-]{11})", content):
            ids.add(match.group(1))
        for match in re.finditer(r"youtu\.be/([a-zA-Z0-9_-]{11})", content):
            ids.add(match.group(1))
    return ids


# ---------------------------------------------------------------------------
# Playlist management (OAuth2 required)
# ---------------------------------------------------------------------------

def remove_from_playlist(playlist_item_id: str) -> bool:
    """Remove a video from a playlist by its playlist-item ID.

    Requires OAuth2 — run ``python youtube_auth.py`` first.
    """
    headers = _oauth_headers()
    if headers is None:
        log.warning(
            f"Cannot remove {playlist_item_id}: OAuth2 not configured. "
            f"Run 'python youtube_auth.py' to set up."
        )
        return False

    resp = requests.delete(
        "https://www.googleapis.com/youtube/v3/playlistItems",
        params={"id": playlist_item_id},
        headers=headers,
    )

    if resp.status_code == 204:
        log.info(f"Removed playlist item {playlist_item_id} from extract playlist")
        return True

    log.error(
        f"Failed to remove playlist item {playlist_item_id}: "
        f"{resp.status_code} {resp.text}"
    )
    return False


def add_to_playlist(video_id: str, playlist_id: str) -> bool:
    """Add a video to a playlist (e.g. the completed playlist).

    Requires OAuth2 — run ``python youtube_auth.py`` first.
    """
    headers = _oauth_headers()
    if headers is None:
        log.warning(
            f"Cannot add {video_id} to playlist: OAuth2 not configured. "
            f"Run 'python youtube_auth.py' to set up."
        )
        return False

    body = {
        "snippet": {
            "playlistId": playlist_id,
            "resourceId": {
                "kind": "youtube#video",
                "videoId": video_id,
            },
        }
    }

    resp = requests.post(
        "https://www.googleapis.com/youtube/v3/playlistItems",
        params={"part": "snippet"},
        headers={**headers, "Content-Type": "application/json"},
        json=body,
    )

    if resp.status_code in (200, 201):
        log.info(f"Added video {video_id} to playlist {playlist_id}")
        return True

    log.error(
        f"Failed to add video {video_id} to playlist {playlist_id}: "
        f"{resp.status_code} {resp.text}"
    )
    return False


def move_video_to_completed(video_id: str, playlist_item_id: str) -> bool:
    """Move a video: remove from extract playlist, add to completed playlist.

    This is the main entry point called after a successful extraction.
    Falls back gracefully if OAuth is not configured or completed playlist
    is not set.
    """
    if not oauth_available():
        log.info(
            f"OAuth not configured — skipping playlist move for {video_id}. "
            f"Run 'python youtube_auth.py' to enable."
        )
        return False

    removed = remove_from_playlist(playlist_item_id)

    # Add to completed playlist if configured
    if config.YOUTUBE_COMPLETED_PLAYLIST_ID:
        add_to_playlist(video_id, config.YOUTUBE_COMPLETED_PLAYLIST_ID)
    else:
        log.debug("No YOUTUBE_COMPLETED_PLAYLIST_ID set — skipping add-to-completed")

    return removed
